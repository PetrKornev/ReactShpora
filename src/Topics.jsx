export const topics = [
  {
    path: 'components',
    title: 'Components',
    content: [
      {
        q: 'Что такое компонента?',
      },
      {
        a: 'Это небольшие, переиспользуемые кусочки кода, которые управляют отображением и поведением пользовательского интерфейса.',
      },
      { q: 'Какими они бывают?' },
      {
        a: 'Компноненты бывают классовыми и функциональми. Функциональные компоненты — это простые функции, которые принимают props и возвращают JSX. Они являются наиболее современным и популярным способом написания компонентов.',
      },
      { a: 'Пример функционального компонента:' },
      { c: 'function Greeting() {\n return <h1>Привет!</h1>} \n}' },
      { a: 'Пример классового компонента:' },
      {
        c: 'class Greeting extends Component { \n render() { \n return <h1>Привет!</h1>\n } \n }',
      },
      {
        a: 'Что бы вызвать компонент, мы должны вставить его, например в App.jsx (предварительно импортировав его), следующим образом: <Greeting/>',
      },
      { q: 'Какая разница между компонентом и элементом?' },
      {
        a: 'React компонент - это функция или класс, который возвращает JSX. Он описывает как должен выглядеть интерфейс. Примеры смотри выше.',
      },
      {
        a: 'React элемент - это объект JS, который реакт создает из JSX. Элемент описывает конткретный узел UI (т.е. что именно нужно отрендерить. Пример:',
      },
      {
        c: 'const element = <h1>Привет!</h1>',
      },
      { a: 'На самом деле это объект:' },
      { c: '{\n type: "h1", \n props: { children: "Привет!" } \n }' },
      { q: 'Основные характеристики компонентов' },
      {
        s: [
          'Независимость. Каждый компонент работает независимо от других. Это значит, что изменения в одном компоненте не затронут другие.',
          'Переиспользуемость. Компоненты можно использовать повторно в разных частях приложения, что снижает количество дублирующегося кода.',
          'Иерархия.  Компоненты могут быть вложенными: родильский компонент передаёт данные дочерним через props.',
          'Компонента должна себя вести как чистая функция.  Чистая функция - это функция, которая для одинаковых входных данных всегда возвращает один резельтат, не имеет побочных эффектов( то есть не изменяет внешние состояния) и не зависит от внешних состояния',
        ],
      },
    ],
  },
  {
    path: 'props',
    title: 'Props',
    content: [
      { q: 'Что такое props?' },
      {
        a: 'Props — это объект, содержащий данные, которые передаются в компонент из его родителя. Props похожи на параметры функций: они предоставляют компонентам необходимую информацию для корректной работы.',
      },
      { q: 'Как передать props?' },
      {
        a: 'Props передаются в компоненты так же, как атрибуты в HTML-элементы. Можно представить, что props - это параметры, которые передаются функции при ее вызове. Пример:',
      },
      {
        c: 'function welcome(props) { \n return <h1>Welcome, {props.userName}!</h1> \n } \n\n <Welcome userName={"Petr"} />',
      },
      { a: 'Пример с числом и булевыми значениями' },
      {
        c: `function UserStatus(props) {
  return (
    <div>
      <p>User ID: {props.id}</p>
      <p>Status: {props.isActive ? 'Active' : 'Inactive'}</p>
    </div>
  );
}

<UserStatus id={123} isActive={true} />;`,
      },
      { q: 'Как принять props?' },
      { a: 'Пропсы доступны как объект внутри компонента: ' },
      {
        c: `function Profile(props) {
  return <p>Name: {props.name}</p>;
}
<Profile name={"Pavel"} />;`,
      },
      {
        a: 'Так как пропс - это объект, и что бы не загромождать код, можно и нужно использовать деструктуризацию. Пример: ',
      },
      {
        c: `function Profile({ name, age }) {
  return (
    <div>
      <p>Name: {name}</p>
      <p>Age: {age}</p>
    </div>
  );
}
<Profile name={"Pavel"} age={27} />;`,
      },
      { q: 'Что можно передавать в качестве props?' },
      { a: 'В пропсы можно передавать абсолютно любой тип данных!' },
      { q: 'Можно ли изменять props?' },
      { a: 'Нет, props только для чтения, их нельзя изменять напрямую!!!' },
    ],
  },
  {
    path: 'state',
    title: 'State',
    content: [
      { q: 'Что такое State?' },
      {
        a: 'State (состояние) в React — это место, где компонент хранит свои динамические данные',
      },
      { q: 'Чем отличается state от props?' },
      {
        s: [
          'Props передаются компоненту "снаружи", от родителя и неизменные',
          'State управляет внутри компонента и изменяется',
        ],
      },
      {
        q: 'Что такое useState? Зачем он нужен? Какие у него параметры? Что возвращает useState?',
      },
      {
        a: 'В функциональных компонентах для работы со state используется хук useState. Он возвращает массив из двух элементов:',
      },
      {
        s: [
          'state: текущее зачение сотояния',
          'setState: функцию для его обновления',
        ],
      },
      {
        a: 'А принимает в свою очередь initialState - начальное значения состояния. Может быть примитивом, объектом или функцией',
      },
      {
        c: `import React, { useState } from 'react';

const [state, setState] = useState(initialState);`,
      },
      { q: 'Как изменяется значение state?' },
      {
        a: 'Напрямую state изменять нельзя. Если это сделать - реакт не поймёт, что нужно обновить интерфйс.',
      },
      { a: 'Как раз для изменения стейта мы используем функцию setState' },
      { c: 'setCount((prevCount) => prevCount + 1);' },
      {
        q: 'Какие есть параметры у фукции-setter? В каком случае нужно использовать функцию как первый параметр функции-setter?',
      },
      {
        a: 'Функция принимает только один параметр - это либо новое значение, либо функция, которая вычисляет новое значение на основе предыдущего. \n Функцию используем тогда, когда у нас есть прямая зависимость от предыдущего значения. Например увеличение счетчика.',
      },
      { q: 'Что происходит, когда вызывается функция-setter?' },
      {
        s: [
          'Реакт ставить задачу в очередья обновлений, когда мы вызываем сеттер',
          'Реакт сравнивает значения. Если новое значение совпадает со старым, то перерисовки не будет',
          'Происходит обновление состояния',
          'Перерендер компонента - реакт вызывает функцию-компонент еще раз с новым state',
        ],
      },
      { q: 'setState - асинхронная или синхронная функция?' },
      {
        a: 'Асинхронная',
      },
    ],
  },
  {
    path: 'lifecycle',
    title: 'Life Cycle',
    content: [
      { q: 'Что такое LifeCycle? Перечислите методы жизненного цикла' },
      {
        a: 'В процессе работы компонент проходит через ряд этапов жизненного цикла. На каждом этапе вызывается определенная функция, в которой мы можем определить какое-либо действие.',
      },
      { a: 'У каждого компонента в React есть три основных фазы:' },
      { s: ['Монтирование', 'Обновление', 'Размонтирование'] },
      { h: 'Монтирование' },
      {
        a: 'Монтирование означает размещение элементов в DOM. React имеет четыре встроенных метода, которые вызываются в этом порядке при монтировании компонента:',
      },
      {
        s: [
          'constructor() - Здесь происходит инициализация состояния и привязка методов',
          'render() - метод, который возвращает JSX-разметку. Вызывается при создании и обновлении компонента.',
          'componentDidMount() - вызывается один раз после того, как компонент вставлен в DOM.',
        ],
      },
      { h: 'Обновление' },
      {
        a: 'Следующим этапом жизненного цикла является обновление компонента. Компонент обновляется всякий раз, когда происходит изменение компонента state или props. React имеет следующие встроенные методы, которые вызываются в указанном порядке при обновлении компонента:',
      },
      {
        s: [
          'shouldComponentUpdate() - позволяет контролировать, следует ли перерисовывать компонент.',
          'render() - Вызывается снова для обновления отображения.',
          'componentDidUpdate() - Вызывается сразу после обновления компонента. Здесь можно реагировать на изменение данных.',
        ],
      },
      { h: 'Размонтирование' },
      {
        a: 'Следующий этап жизненного цикла - это когда компонент удаляется из DOM. В React есть только один встроенный метод, который вызывается при размонтировании компонета:',
      },
      { s: ['componentWillUnmount()'] },
      { q: 'Что такое useEffect?' },
      {
        a: 'Тк сегодня большинство разработчиков используют функциональные компоненты, а не классовы, то вместо методов жизненного цикла применяется хук useEffect',
      },
      {
        a: 'useEffect - это хук в React, предназначенный для работы с методами жизненного цикла в функциональных компонентах',
      },
      { q: 'Какие параметры у useEffect?' },
      { a: 'У useEffect 2 параметра:' },
      {
        s: [
          'Функция, которая должна выполниться при монтировании компонента и при каждом обновлении.',
          'Массив зависимостей определяет, на что конретно должен реагировать useEffect. Если массив пуст, useEffect выполняется только при монтировании и размонтировании. Если в массиве указаны определенные значения, то useEffect будет выполняться только тогда, когда эти значения изменяются.',
        ],
      },
      { q: 'Как реализовать componentDidMount с помощью useEffect?' },
      { c: 'useEffect(() => {}, [])' },
      { q: 'Как реализовать componentDidUpdate с помощью useEffect?' },
      { c: 'useEffect(() => {}, [dependency])' },
      { q: 'Почему вариант выше отрабатывает при первом render?' },
      {
        a: 'В React хуки, такие как useEffect, выполняются при каждом рендере компонента, включая первый рендер после монтирования. Это особенность работы хуков, и они не повторяют точно поведение метода жизненного цикла comonentDidMount из классовых компонентов.',
      },
      { q: 'Как реализовать componentWillUnmount с помощью useEffect?' },
      { c: 'useEffect(() => () => {})' },
      { q: 'Когда срабатывает componentWillUnmount?' },
      {
        a: 'Вызывается перед тем, как компонент будет удален из DOM. Обычно используется для "уборки": ',
      },
      {
        s: [
          'Отписка от таймеров',
          'Отмена сетевых запросов',
          'Очистка любых ресурсов, связанных с компонентом',
        ],
      },
      {
        c: `useEffect(() => {
  const interval = setInterval(() => console.log("Тик"), 1000);
  return () => clearInterval(interval); // сработает при unmount
}, []);
`,
      },
      { a: 'Или в классовом компоненте:' },
      {
        c: `class Timer extends React.Component {
  componentDidMount() {
    this.interval = setInterval(() => console.log("Тик"), 1000);
  }

  componentWillUnmount() {
    clearInterval(this.interval); // очистка
    console.log("Компонент удалён!");
  }

  render() {
    return <h1>Таймер работает...</h1>;
  }
}
`,
      },
      { q: 'useEffect vs useLayoutEffect' },
      { h: 'useEffect' },
      {
        s: [
          'Срабатывает после того, как React обновил DOM и браузер отрисовал изменения',
          'Асинхронный по сути -> не блокирует рендер',
          'Подходит для: запросов к API, подписок, логов, работы с локальным хранилизем и тд.',
        ],
      },
      { h: 'useLayoutEffect' },
      {
        s: [
          'Сраатывает срау после обновления DOM, но до того как браузер покажет изменения пользователю',
          'Синхронный -> блокирует рендер до выолнения',
          'Подходит для: измерения размеров DOM-элементов, синхронизации скролла, манипуляий с layout',
        ],
      },
    ],
  },
];
